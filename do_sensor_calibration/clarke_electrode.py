import numpy as np
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt
from datasaver import DataSaver
import matplotlib
matplotlib.use('TkAgg')
import os


class ClarkeElectrode:
    """
    A class to model and calibrate a Clarke electrode, compensating for temperature effects.
    """

    def __init__(self, atmospheric_pressure: float = 760.0, datasaver: DataSaver = None):
        self.atmospheric_pressure = atmospheric_pressure
        try:
            vapor_pressure_data = np.loadtxt(r"water_vapor_pressure.csv", delimiter=',', skiprows=2)
            self.vapor_pressure_temp_range = (vapor_pressure_data[:,0].min(), vapor_pressure_data[:, 0].max())
            print(self.vapor_pressure_temp_range)
            self.vapor_pressure_func = interp1d(vapor_pressure_data[:, 0], vapor_pressure_data[:, 1], bounds_error=True)
        except FileNotFoundError:
            print("Error: 'water_vapor_pressure.csv' not found. Please ensure the file is in the script's directory.")
            exit()

        self.data_saver = datasaver if datasaver else DataSaver() # Use provided DataSaver or create a new one
        self.is_calibrated = False
        self.cal_temp_range = [None, None]  # Temperature range in which calibration is valid
        self.cal_saturation = [0.0, 0.2095]  # Default saturation points for low and high calibration
        self.cal_model = [None, None]  # Placeholder for calibration models
        self.cal_voltage_range = [None, None]
    def _slice_data(self, do_array, temp_array: np.array, do_sensor_index: int, temp_sensor_index: int, start_time=None,
                                  end_time=None,plot=False):
        """
        Accepts raw data loaded from datasaver.read_do_data and datasaver.read_temp_data and slices the array to keep
        the selected sensors between start_time and end_time
        Args:
            do_sensor_index (int): The index ID for the dissolved oxygen sensor to be used.
            temp_sensor_index (int): The index ID for the temperature sensor to be used.
            start_time (float, optional): The start timestamp to slice the data. Defaults to None.
            end_time (float, optional): The end timestamp to slice the data. Defaults to None.
            plot (bool, optional): Optionally plot the data from the sliced arrays.

        Returns:
            np.ndarray, np.ndarray: sliced_do_array, sliced_temp_array
        """
        # Create the final do_data array with only timestamp (col 0) and the selected sensor's data
        do_data_sliced = do_array[:, [0, do_sensor_index]]

        # --- Find and Slice Temperature Data ---
        header_row_temp = temp_array[0, :]
        found_temp_indices = np.where(header_row_temp == temp_sensor_index)[0]

        if found_temp_indices.size == 0:
            print(f"Error: Temperature sensor index '{temp_sensor_index}' not found in temp data.")
            return None, None

        temp_column_index = found_temp_indices[0] + 1
        # Create the final temp_data array with only timestamp (col 0) and the selected sensor's data
        temp_data_sliced = temp_array[:, [0, temp_column_index]]
        # --- Slice data based on start and end time if provided ---
        if start_time is not None:
            do_data_sliced = do_data_sliced[do_data_sliced[:, 0] >= start_time]
            temp_data_sliced = temp_data_sliced[temp_data_sliced[:, 0] >= start_time]
        if end_time is not None:
            do_data_sliced = do_data_sliced[do_data_sliced[:, 0] <= end_time]
            temp_data_sliced = temp_data_sliced[temp_data_sliced[:, 0] <= end_time]

        if plot:
            try:
                fig, ax = plt.subplots(figsize=(10, 6),nrows=2)
                ax[0].plot(do_data_sliced[:,0], do_data_sliced[:,1], 'o', label='DO Data')
                ax[1].plot(temp_data_sliced[:,0],temp_data_sliced[:,1], 'o', label='Temp Data')
                plt.xlabel('Timestamp')
                plt.ylabel('Temperature (°C)')
                plt.title('Temperature Data Interpolation')
                plt.legend()
                plt.show()

            except Exception as e:
                print(f"Error during plotting: {e}")





        return do_data_sliced,temp_data_sliced

    def _interpolate_temperature(self, temperature_array: np.array, do_array: np.array, plot = False):
        """
        Accepts a temperature and do_array generated by the datasaver.read_do_data and datasaver.read_temp_data
        and reinterpolates the temperature array (slower sampling) at the same sampling frequency as the do_array
        (faster sampling)

        Args:
            temp_array (np.array)
            do_array (np.array)
        returns:
            resampled_temp (np.array)

        """
        try:
            self.temp_interp_func = interp1d(temperature_array[:, 0], temperature_array[:, 1], kind='linear', fill_value="extrapolate")
            resampled_temp = np.zeros(do_array.shape)
            resampled_temp[:, 0] = do_array[:, 0]
            resampled_temp[:, 1] = self.temp_interp_func(do_array[:, 0])

        except Exception as e:
            print(f"Error during temperature interpolation: {e}")
            return None

        if plot:
            try:
                plt.figure(figsize=(10, 6))
                plt.plot(temperature_array[:, 0], temperature_array[:, 1], 'o', label='Original Temp Data')
                plt.plot(resampled_temp[:, 0], resampled_temp[:,1], '-', label='Interpolated Temp Data')
                plt.xlabel('Timestamp')
                plt.ylabel('Temperature (°C)')
                plt.title('Temperature Data Interpolation')
                plt.legend()
                plt.show()

            except Exception as e:

                print(f"Error during plotting: {e}")
                return resampled_temp

        return resampled_temp


    def compute_vapour_pressure(self, temperature_celsius):
        """
        :param temperature_celsius:
        :return:
        Computes the water vapour pressure in mmHg for a given temperature in Celsius using interpolation.
        """
        if np.any((temperature_celsius < self.vapor_pressure_temp_range[0]) | (temperature_celsius > self.vapor_pressure_temp_range[1])):
            raise ValueError(f"Temperature {temperature_celsius}°C is out of range for vapor pressure data ("
                             f"{self.vapor_pressure_temp_range[0]}°C to {self.vapor_pressure_temp_range[1]}°C).")
        return self.vapor_pressure_func(temperature_celsius)

    def plot_vapour_pressure(self):
        temps = np.linspace(self.vapor_pressure_temp_range[0], self.vapor_pressure_temp_range[1], 200)
        vps = self.compute_vapour_pressure(temps)
        plt.figure(figsize=(10, 6))
        plt.plot(temps, vps, label='Water Vapour Pressure', color='blue')
        plt.title('Water Vapour Pressure vs Temperature')
        plt.xlabel('Temperature (°C)')
        plt.ylabel('Vapour Pressure (mmHg)')
        plt.legend()
        plt.grid(True)
        plt.show()

    def compute_henrys_pO2(self, temperature, so2: float = 0.2095):
        " Computes the theoretical water pO2 in mmHg for a given temperature and saturation percentage using Henry's Law. "
        water_vp = self.compute_vapour_pressure(temperature)
        po2 = (self.atmospheric_pressure - water_vp) * (so2)
        return po2

    def calibrate(self, point_type: str, temp_array: np.array, do_array: np.array, saturation: float = None, plot: bool = False):
        """
        Calibrates the electrode using provided temperature and do data for either the low (0%) or high (20.95%) point.
        0% point should be calibrated in an anoxic environment (e.g. sodium sulfite solution)
        20.95% point should be calibrated in air-saturated water at the local atmospheric pressure
        calibrate method needs to be called twice, once for each point.
        Args:
        :param point_type: low or high
        :param temp_array: 2D numpy array with timestamps in col 0 and temperature in col 1
        :param do_array: 2D numpy array with timestamps in col 0 and do voltage in col 1
        :return:
        """
        #check point_type is high or low
        if point_type.lower() not in ['low', 'high']:
            raise ValueError("point_type must be either 'low' or 'high'")

        #check that temp_array and do_array have equivalent timestamps
        have_same_timestamps = np.array_equal(temp_array[:, 0], do_array[:, 0])
        if not have_same_timestamps:
            raise ValueError("Temperature and DO arrays must have matching timestamps for calibration. Use ._interpolate_temperature() to align them.")
        if point_type.lower() == 'low':
            cal_model_idx = 0
            if saturation is None:
                self.cal_saturation[0] = 0.0
            else:
                self.cal_saturation[0] = saturation

        if point_type.lower() == 'high':
            cal_model_idx = 1
            if saturation is None:
                self.cal_saturation[1] = 0.2095
            else:
                self.cal_saturation[1] = saturation

        #make a polynomial fit
        try:
            self.cal_model[cal_model_idx] = np.polyfit(temp_array[:, 1], do_array[:, 1], deg=1)
        except Exception as e:
            print(f"Error during calibration fitting: {e}")
            self.cal_model[cal_model_idx] = None
            return None

        #check if both points are calibrated
        self.is_calibrated = all(model is not None for model in self.cal_model)

        #temp range is the overlapping range of the two calibration points

        # After
        if self.cal_temp_range[0] is None or temp_array[:,1].min() > self.cal_temp_range[0]:
            self.cal_temp_range[0] = temp_array[:,1].min()

        if self.cal_temp_range[1] is None or temp_array[:,1].max() < self.cal_temp_range[1]:
            self.cal_temp_range[1] = temp_array[:,1].max()

        #voltage range is the overlapping range of the two calibration points

        if self.cal_voltage_range[0] is None or do_array.min() > self.cal_voltage_range[0]:
            self.cal_voltage_range[0] = do_array[:,1].min()
        if self.cal_voltage_range[1] is None or do_array[:,1].max() < self.cal_voltage_range[1]:
            self.cal_voltage_range[1] = do_array[:,1].max()

        if plot:
            try:
                fig, ax = plt.subplots(figsize=(10, 6))
                ax.scatter(temp_array[:, 1], do_array[:,1], label='Data Points', color='blue' if point_type.lower() == 'low' else 'red')
                ax.plot(temp_array[:, 1], np.polyval(self.cal_model[cal_model_idx], temp_array[:, 1]), 'k--',
                        label=f'Calibration Fit: {self.cal_model[cal_model_idx][0]:.4f}x + {self.cal_model[cal_model_idx][1]:.4f}')
                ax.set_title(f'{point_type.capitalize()} Point Calibration Fit - Saturation: {self.cal_saturation[cal_model_idx]*100:.2f}%\n'
                             f'DO Voltage vs Temperature')
                ax.set_ylabel('DO sensor Raw Voltage (V)')
                ax.set_xlabel('Temperature (°C)')
                plt.legend()
                plt.show()
            except Exception as e:
                print(f"Error during plotting: {e}")

        return self.cal_model[cal_model_idx]

    def get_po2(self, measured_voltage: float, temperature: float):
        """
        Computes the partial pressure of oxygen (pO2) in mmHg from a measured voltage and temperature using the calibration models.
        Args:
        :param measured_voltage float or np.array: The measured voltage from the DO sensor.
        :param temperature: float or np.array: The temperature in Celsius at which the voltage was measured.
        :return:
        If the sensor is calibrated
        po2 in mmHg : float or np.array
        """
        if not self.is_calibrated:
            raise RuntimeError("Sensor is not calibrated. Please calibrate both low and high points before attempting"
                               " pO2 conversion.")
        #assess that temperature and measured_voltage are either both float or both np.array of same length
        argument_check = False
        if isinstance(measured_voltage, float) and isinstance(temperature, float):
            argument_check = True
        elif isinstance(measured_voltage, np.ndarray) and isinstance(temperature, np.ndarray):
            if measured_voltage.shape == temperature.shape:
                argument_check = True
        if not argument_check:
            raise ValueError("measured_voltage and temperature must be either both float or both np.array of the same shape.")

        henrys_pO2 = self.compute_henrys_pO2(temperature, so2=self.cal_saturation[1])
        Vhigh = np.polyval(self.cal_model[1], temperature)
        Vlow = np.polyval(self.cal_model[0], temperature)
        po2 = henrys_pO2 * (measured_voltage - Vlow) / (Vhigh - Vlow)
        return po2
    def plot_calibration(self):
        #create meshgrid for temperature and voltage
        if not self.is_calibrated:
            raise RuntimeError("Sensor is not calibrated. Please calibrate both low and high points before attempting"
                               " to plot calibration.")
        temp_range = np.linspace(self.cal_temp_range[0], self.cal_temp_range[1], 100)
        volt_range = np.linspace(self.cal_voltage_range[0], self.cal_voltage_range[1], 100)
        Temp_mesh, Volt_mesh = np.meshgrid(temp_range, volt_range)
        PO2_mesh = self.get_po2(Volt_mesh, Temp_mesh)
        fig = plt.figure(figsize=(12, 8))
        ax = fig.add_subplot(111)
        surf = ax.contourf(Temp_mesh, Volt_mesh, PO2_mesh, cmap='viridis',levels = 300)
        ax.set_title('Calibrated pO2 Surface')
        ax.set_xlabel('Temperature (°C)')
        ax.set_ylabel('DO Sensor Voltage (V)')
        fig.colorbar(surf, ax=ax, shrink=0.5, aspect=5, label='pO2 (mmHg)')
        plt.show()


if __name__ == "__main__":
    # --- This section demonstrates how to use the class ---
    # To make this example runnable, we first CREATE some mock asynchronous data files.
    # 1. SETUP
    local_pressure_mmhg = 758.0
    electrode = ClarkeElectrode(atmospheric_pressure=local_pressure_mmhg)
    # 2. SYNCHRONIZE AND CALIBRATE
    print("--- Starting Calibration ---")
    path = r"C:\Users\marca\PycharmProjects\MMEP-Control-GUI\calibration_test.csv"
    # Step A: Synchronize and calibrate the LOW point
    datasaver = DataSaver()
    temp_array = datasaver.read_temp_data(path)
    do_array = datasaver.read_do_data(path)
    sliced_do, sliced_temp = electrode._slice_data(temp_array=temp_array, do_array=do_array ,do_sensor_index=1,
                                                   temp_sensor_index=1,start_time=1.9e6, end_time=2.2e6, plot=False)
    #interpolate
    resampled_temp = electrode._interpolate_temperature(temperature_array=sliced_temp, do_array=sliced_do,plot=False)
    #calibrate
    electrode.calibrate(point_type='high', temp_array=resampled_temp, do_array=sliced_do, saturation=0.2095, plot=True)
    ## generate falso data for low point
    low_temp = np.zeros((1000,2))
    low_temp[:,0] = np.linspace(3.0e6, 3.3e6, 1000)
    low_temp[:,1] = np.linspace(25, 38, 1000)
    low_volt = np.zeros((1000,2))
    low_volt[:,0] = low_temp[:,0]
    low_volt[:,1] = 0.004 * low_temp[:,1] - 0.075 + np.random.normal(0, 0.002, 1000)
    electrode.calibrate(point_type='low', temp_array=low_temp, do_array=low_volt, saturation=0.0, plot=True),
    print(electrode.cal_voltage_range)
    print(electrode.cal_temp_range)
    electrode.plot_calibration()